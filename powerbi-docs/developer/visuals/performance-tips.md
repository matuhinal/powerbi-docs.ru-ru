---
title: Советы по повышению производительности
description: Как создать высокопроизводительный визуальный элемент Power BI
author: KesemSharabi
ms.author: kesharab
ms.reviewer: sranins
ms.service: powerbi
ms.subservice: powerbi-custom-visuals
ms.topic: how-to
ms.date: 04/20/2020
ms.openlocfilehash: c22c634ef59a1aae2994dcacaae62dc8ebed7474
ms.sourcegitcommit: 6bc66f9c0fac132e004d096cfdcc191a04549683
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/06/2020
ms.locfileid: "91746085"
---
# <a name="how-to-build-a-high-performance-power-bi-visual"></a>Как создать высокопроизводительный визуальный элемент Power BI
В этой статье рассматриваются методы, позволяющие разработчикам добиться высокой производительности при отрисовке визуальных элементов. 

Никто не хочет, чтобы отрисовка визуального элемента занимала много времени, так как получение производительности кода при отрисовке критически важно. 

> [!NOTE]
> Так как мы совершенствуем и улучшаем платформу, постоянно выпускаются новые версии API. Чтобы максимально эффективно использовать платформу и набор функций визуальных элементов Power BI, рекомендуется иметь актуальную версию.
>
> Начиная с последней **версии 2.1**, время загрузки визуальных элементов Power BI улучшилось в среднем на 20 %.

## <a name="power-bi-visual-performance-tips"></a>Советы по улучшению производительности для визуальных элементов Power BI
Ниже приведены рекомендации по обеспечению оптимальной производительности визуальных элементов. 

### <a name="use-user-timing-api"></a>Использование API расчета времени пользователя
С помощью **API расчета времени пользователя** для измерения производительности приложения JavaScript можно решить, какие части скрипта нуждаются в оптимизации.

Дополнительные сведения см. в статье [об API расчета времени пользователя](https://msdn.microsoft.com/library/hh772738(v=vs.85).aspx).

### <a name="review-animation-loops"></a>Проверка циклов анимации
Перерисовываются ли неизмененные элементы в цикле анимации? 

 - Проблема. На прорисовку элементов, которые не меняются в каждом кадре, тратится время.

 - Решение: Обновляйте кадры выборочно. 
 
Когда речь заходит об анимации статических визуализаций, то заманчивой идеей является объединение кода для рисования в одну функцию обновления и вызов ее повторно с новыми данными для каждой итерации цикла анимации.

Вместо этого рассмотрите указанный ниже шаблон обновления. Используйте метод конструктора визуальных элементов для отрисовки всех статических элементов, тогда функции обновления нужно будет отобразить только элементы визуализации, которые изменяются. 

   > [!TIP]
   > Неэффективные циклы анимации обычно встречаются по осям и в условных обозначениях.

### <a name="cache-dom-nodes"></a>Узлы кэша модели DOM 
Если узел или список узлов извлекается из модели DOM, необходимо подумать о том, можно ли повторно их использовать в последующих вычислениях (иногда даже в следующей итерации цикла). Если вам не нужно добавлять или удалять дополнительные узлы в соответствующей области, их кэширование может повысить общую эффективность приложения.

Чтобы убедиться в том, что код работает быстро и не замедляет работу браузера, сохраняйте доступ модели DOM на минимальном уровне. 

- Перед следующей операцией. 

   ```javascript
   public update(options: VisualUpdateOptions) { 
       let axis = $(".axis"); 
   }
   ```

- После следующих операций. 

   ```javascript
   public constructor(options: VisualConstructorOptions) { 
       this.$root = $(options.element); 
       this.xAxis = this.$root.find(".xAxis"); 
   } 
 
   public update(options: VisualUpdateOptions) { 
       let axis = this.axis; 
   }
   ```

### <a name="avoid-dom-manipulation"></a>Предотвращение обработки модели DOM 
Максимально ограничьте обработку модели DOM.  Для выполнения таких операций вставки, как `prepend()`, `append()` и `after()`, требуются значительные затраты времени, поэтому используйте их только при необходимости.

Например:

  ```javascript
  for (let i=0; i<1000; i++) { 
      $('#list').append('<li>'+i+'</li>');
  }
  ```

Приведенный выше пример можно ускорить с помощью `html()` и предварительно создав список: 

  ```javascript
  let list = ''; 
  for (let i=0; i<1000; i++) { 
      list += '<li>'+i+'</li>'; 
  } 

  $('#list').html(list); 
  ```

### <a name="reconsider-jquery"></a>Пересмотр JQuery

Ограничение платформ JS и использование по возможности собственного JS могут увеличить доступную пропускную способность и снизить затраты на обработку. Это также может устранить проблемы совместимости со старыми браузерами. 

Перейдите по ссылке [youmightnotneedjquery.com](http://youmightnotneedjquery.com/), чтобы получить дополнительные примеры функций `show`, `hide`, `addClass` и т. д. в JQuery.  

### <a name="use-canvas-or-webgl"></a>Использование холста или WebGL 
Для многократного использования анимаций рекомендуется вместо SVG использовать **холст** или **WebGL**. В отличие от SVG, при использовании этих параметров производительность определяется по размеру, а не по содержимому. 

Дополнительные сведения об их различиях см. в статье [о выборе между SVG и Canvas](/previous-versions/windows/internet-explorer/ie-developer/samples/gg193983(v=vs.85)). 

### <a name="use-requestanimationframe-instead-of-settimeout"></a>Использование requestAnimationFrame вместо setTimeout 
Если вы используете [requestAnimationFrame](https://www.w3.org/TR/animation-timing/) для обновления анимаций на экране, функции анимации вызываются **перед тем**, как браузер вызовет другой метод обновления.

Дополнительные сведения о плавной анимации с помощью `requestAnimationFrame` см. в [этом примере](https://testdrive-archive.azurewebsites.net/Graphics/RequestAnimationFrame/Default.html).

## <a name="next-steps"></a>Дальнейшие действия

Дополнительные сведения о методах оптимизации Power BI см. в [этой статье](../../guidance/power-bi-optimization.md).