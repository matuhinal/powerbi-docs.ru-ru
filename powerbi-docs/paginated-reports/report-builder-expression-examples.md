---
title: Примеры выражений в построителе отчетов Power BI
description: Выражения часто используются в отчетах с разбивкой на страницы в Power BI Report Builder для управления содержимым и внешним видом отчета.
ms.date: 10/21/2019
ms.service: powerbi
ms.subservice: report-builder
ms.topic: conceptual
ms.assetid: 87ddb651-a1d0-4a42-8ea9-04dea3f6afa4
author: maggiesMSFT
ms.author: maggies
ms.openlocfilehash: 48e81c91a4555b4c8ea847ddffb1413058bbb152
ms.sourcegitcommit: 7aa0136f93f88516f97ddd8031ccac5d07863b92
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/05/2020
ms.locfileid: "78921155"
---
# <a name="expression-examples-in-power-bi-report-builder"></a>Примеры выражений в построителе отчетов Power BI
Выражения часто используются в отчетах с разбивкой на страницы в Power BI Report Builder для управления содержимым и внешним видом отчета. Выражения записываются на языке Microsoft Visual Basic, и в них можно использовать встроенные функции, пользовательский код, переменные отчета, групповые переменные и определяемые пользователем переменные. Выражения начинаются со знака равенства (=).   

В этом разделе приведены примеры выражений, которые можно использовать для решения типичных задач в отчете.  
  
-   [Функции языка Visual Basic](#VisualBasicFunctions) — примеры функций дат, строковых функций, функций преобразования и условных функций Visual Basic.  
  
-   [Функции отчета](#ReportFunctions) — примеры агрегатных функций и других встроенных функций отчета.  
  
-   [Внешний вид данных отчета](#AppearanceofReportData) — примеры изменения внешнего вида отчета.  
  
-   [Свойства](#Properties) — примеры задания свойств элемента отчета, отвечающих за формат или видимость.  
  
-   [Параметры](#Parameters) — примеры использования параметров в выражении.  
  
-   [Пользовательский код](#CustomCode) — примеры внедренного пользовательского кода.  
  
Дополнительные сведения о простых и сложных выражениях, о местах, где можно использовать выражения, и о типах ссылок, которые можно включать в выражения, см. в подразделах раздела [Выражения в построителе отчетов Power BI](report-builder-expressions.md). 
  
## <a name="functions"></a>Функции  
 Многие выражения в отчете содержат функции. Они позволяют форматировать данные, применять логику и обращаться к метаданным отчета. В выражениях можно использовать функции из библиотеки времени выполнения Microsoft Visual Basic, а также из пространств имен `xref:System.Convert` и `xref:System.Math`. Можно добавить ссылки на функции в пользовательском коде. Кроме того, можно использовать классы из Microsoft .NET Framework, в том числе `xref:System.Text.RegularExpressions`.  
  
##  <a name="visual-basic-functions"></a><a name="VisualBasicFunctions"></a> Функции языка Visual Basic  
 Функции языка Visual Basic позволяют управлять данными, отображаемыми в текстовых полях или используемыми для параметров, свойств и в других областях отчета. В этом разделе приведены примеры применения некоторых из этих функций. Дополнительные сведения см. в разделе [Компоненты библиотеки времени выполнения Visual Basic](https://go.microsoft.com/fwlink/?LinkId=198941) в MSDN.  
  
 Платформа .NET Framework предоставляет множество параметров пользовательских форматов, например для конкретных форматов даты. Дополнительные сведения см. в статье [Типы форматирования](/dotnet/standard/base-types/formatting-types).  
  
### <a name="math-functions"></a>Математические функции  
  
-   Функция **Round** полезна при округлении чисел до ближайшего целого числа. В следующем выражении значение 1,3 округляется до 1:  
  
    ```  
    = Round(1.3)  
    ```  
  
     Можно также написать выражение, которое округляет значение до указанного кратного, подобное функции **MRound** в Excel. Умножьте значение на коэффициент, образующий целое число, округлите число, а затем разделите его на тот же коэффициент. Например, для округления числа 1,3 до ближайшего числа, кратного 0,2 (1,4), воспользуйтесь следующим выражением:  
  
    ```  
    = Round(1.3*5)/5  
    ```  
  
###  <a name="date-functions"></a><a name="DateFunctions"></a> Функции для работы с датами  
  
-   Функция **Today** возвращает текущую дату. Следующее выражение можно указать в текстовом поле для вывода даты формирования отчета или в качестве параметра фильтрации данных на основе текущей даты.  
  
    ```  
    =Today()  
    ```  
  
-   Для извлечения определенной части даты используйте функцию **DateInterval**. Вот некоторые допустимые параметры **DateInterval**:

    -   DateInterval.Second
    -   DateInterval.Minute
    -   DateInterval.Hour
    -   DateInterval.Weekday
    -   DateInterval.Day
    -   DateInterval.DayOfYear
    -   DateInterval.WeekOfYear
    -   DateInterval.Month
    -   DateInterval.Quarter
    -   DateInterval.Year

    Например, это выражение выводит номер недели в текущем году для текущей даты:
  
    ```  
    =DatePart(DateInterval.WeekOfYear, today()) 
    ```  
  
-   Функция **DateAdd** может оказаться полезной для вычисления диапазона дат на основе одного параметра. Следующее выражение вычисляет дату, которая находится на шесть месяцев позже даты, указанной в параметре *StartDate*.  
  
    ```  
    =DateAdd(DateInterval.Month, 6, Parameters!StartDate.Value)  
    ```  
  
-   Функция **Year** отображает год для конкретной даты. Это можно использовать для группирования по датам или для вывода года в качестве метки для набора дат. Выражение возвращает год для заданной группы дат заказов на продажу. Для работы с датами можно также пользоваться функцией **Month** и другими. Дополнительные сведения см. в документации по Visual Basic.  
  
    ```  
    =Year(Fields!OrderDate.Value)  
    ```  
  
-   Для настройки формата функции можно объединять в выражение. Следующее выражение меняет формат даты с формы "месяц-день-год" на форму "месяц-неделя-номер недели". Например, с 12/23/2009 на "декабрь, неделя 3":  
  
    ```  
    =Format(Fields!MyDate.Value, "MMMM") & " Week " &   
    (Int(DateDiff("d", DateSerial(Year(Fields!MyDate.Value),   
    Month(Fields!MyDate.Value),1), Fields!FullDateAlternateKey.Value)/7)+1).ToString  
    ```  
  
     При использовании в качестве вычисляемого поля в наборе данных с помощью этого выражения можно выполнить статистическую обработку значений в диаграмме по неделям каждого месяца.  
  
-   Следующее выражение форматирует значение SellStartDate как МММ-ГГ. Поле SellStartDate имеет тип datetime.  
  
    ```  
    =FORMAT(Fields!SellStartDate.Value, "MMM-yy")  
    ```  
  
-   Следующее выражение форматирует значение SellStartDate как дд/ММ/гггг. Поле SellStartDate имеет тип datetime.  
  
    ```  
    =FORMAT(Fields!SellStartDate.Value, "dd/MM/yyyy")  
    ```  
  
-   Функция **CDate** преобразует это значение в дату. Функция **Now** возвращает значение даты, которое содержит текущую дату и время по часам компьютера. **DateDiff** возвращает значение типа Long, указывающее число интервалов времени между двумя значениями типа Date.  
  
     В следующем примере показана дата начала текущего года.  
  
    ```  
    =DateAdd(DateInterval.Year,DateDiff(DateInterval.Year,CDate("01/01/1900"),Now()),CDate("01/01/1900"))  
    ```  
  
-   В следующем примере показана дата начала прошлого месяца с учетом текущего месяца.  
  
    ```  
    =DateAdd(DateInterval.Month,DateDiff(DateInterval.Month,CDate("01/01/1900"),Now())-1,CDate("01/01/1900"))  
    ```  
  
-   Следующее выражение создает годы интервала между SellStartDate и LastReceiptDate. Эти поля находятся в двух разных наборах данных — DataSet1 и DataSet2.  
  
    ```  
    =DATEDIFF("yyyy", First(Fields!SellStartDate.Value, "DataSet1"), First(Fields!LastReceiptDate.Value, "DataSet2"))  
    ```  
  
-   Функция **DatePart** возвращает значение Integer с указанным компонентом заданного значения Date. Следующее выражение возвращает год первого значения SellStartDate в DataSet1. Область набора данных задана из-за наличия нескольких наборов данных в отчете.  
  
    ```  
    =Datepart("yyyy", First(Fields!SellStartDate.Value, "DataSet1"))  
  
    ```  
  
-   Функция **DateSerial** возвращает значение Date, представляющее указанные год, месяц и день, в котором время установлено на полночь. В следующем примере показана дата окончания прошлого месяца с учетом текущего месяца.  
  
    ```  
    =DateSerial(Year(Now()), Month(Now()), "1").AddDays(-1)  
    ```  
  
-   Следующие выражения отображают разные даты на основе значения параметра даты, выбранного пользователем.  
  
|Описание примера|Пример|  
|-------------------------|-------------|  
|Вчера|`=DateSerial(Year(Parameters!TodaysDate.Value),Month(Parameters!TodaysDate.Value),Day(Parameters!TodaysDate.Value)-1)`|  
|Два дня назад|`=DateSerial(Year(Parameters!TodaysDate.Value),Month(Parameters!TodaysDate.Value),Day(Parameters!TodaysDate.Value)-2)`|  
|Месяц назад|`=DateSerial(Year(Parameters!TodaysDate.Value),Month(Parameters!TodaysDate.Value)-1,Day(Parameters!TodaysDate.Value))`|  
|Два месяца назад|`=DateSerial(Year(Parameters!TodaysDate.Value),Month(Parameters!TodaysDate.Value)-2,Day(Parameters!TodaysDate.Value))`|  
|Год назад|`=DateSerial(Year(Parameters!TodaysDate.Value)-1,Month(Parameters!TodaysDate.Value),Day(Parameters!TodaysDate.Value))`|  
|Два года назад|`=DateSerial(Year(Parameters!TodaysDate.Value)-2,Month(Parameters!TodaysDate.Value),Day(Parameters!TodaysDate.Value))`|  
  
###  <a name="string-functions"></a><a name="StringFunctions"></a> Строковые функции  
  
-   Объединяют несколько полей с помощью операторов объединения и констант Visual Basic. Следующее выражение возвращает два поля, каждое на отдельной строке в одном текстовом поле.  
  
    ```  
    =Fields!FirstName.Value & vbCrLf & Fields!LastName.Value   
    ```  
  
-   Функция **Format** позволяет отформатировать даты и числа в виде строки. Следующее выражение отображает значения параметров *StartDate* и *EndDate* в формате полной даты.  
  
    ```  
    =Format(Parameters!StartDate.Value, "D") & " through " &  Format(Parameters!EndDate.Value, "D")    
    ```  
  
     Если текстовое поле содержит только дату или число, чтобы применить форматирование, лучше использовать свойство Format текстового поля, а не вызывать функцию **Format** в текстовом поле.  
  
-   Функции **Right**, **Len** и **InStr** полезны для извлечения подстроки, например одного лишь имени пользователя из строк вида *ДОМЕН*\\*имя пользователя*. Следующее выражение возвращает часть строки параметра *User*, расположенную справа от символа обратной косой черты (\\):  
  
    ```  
    =Right(Parameters!User.Value, Len(Parameters!User.Value) - InStr(Parameters!User.Value, "\"))  
    ```  
  
     Следующее выражение возвращает то же значение, что и предыдущее, только вместо функций Visual Basic используются члены класса `xref:System.String` платформы .NET Framework:  
  
    ```  
    =Parameters!User.Value.Substring(Parameters!User.Value.IndexOf("\")+1, Parameters!User.Value.Length-Parameters!User.Value.IndexOf("\")-1)  
    ```  
  
-   Отображает выбранные значения из многозначного параметра. В следующем примере функция **Join** объединяет выбранные значения параметра *MySelection* в одну строку, которая может использоваться в качестве выражения для значения текстового поля в элементе отчета:  
  
    ```  
    = Join(Parameters!MySelection.Value)  
    ```  
  
     В следующем примере производится то же, что и в приведенном выше примере, а перед списком выбранных значений отображается строка текста.  
  
    ```  
    ="Report for " & JOIN(Parameters!MySelection.Value, " & ")  
  
    ```  
  
-   Функции **Regex** из `xref:System.Text.RegularExpressions` .NET Framework полезны при изменении формата существующих строк, например при форматировании телефонного номера. Следующее выражение использует функцию **Replace** для изменения формата десятизначного номера телефона в поле с "*nnn*-*nnn*-*nnnn*" на "(*nnn*) *nnn*-*nnnn*":  
  
    ```  
    =System.Text.RegularExpressions.Regex.Replace(Fields!Phone.Value, "(\d{3})[ -.]*(\d{3})[ -.]*(\d{4})", "($1) $2-$3")  
    ```  
  
    > [!NOTE]  
    >  Убедитесь, что значение Fields!Phone.Value не содержит лишних пробелов и имеет тип `xref:System.String`.  
  
### <a name="lookup"></a>Поиск  
  
-   При указании ключевого поля можно использовать функцию **Lookup** для извлечения значения из набора данных со связью "один к одному", например пары "ключ-значение". Следующее выражение отображает из набора данных (Product) название продукта по его идентификатору:  
  
    ```  
    =Lookup(Fields!PID.Value, Fields!ProductID.Value, Fields.ProductName.Value, "Product")  
    ```  
  
### <a name="lookupset"></a>LookupSet  
  
-   При указании ключевого поля можно использовать функцию **LookupSet** для извлечения набора значений из набора данных со связью "один ко многим". Например, у одного человека может быть несколько телефонных номеров. В следующем примере предположим, что набор данных PhoneList содержит в каждой строке идентификатор пользователя и телефонный номер. Функция **LookupSet** возвращает массив значений. В следующем выражении возвращаемые значения объединяются в одну строку. Для пользователя отображается список телефонных номеров по его ContactID:  
  
    ```  
    =Join(LookupSet(Fields!ContactID.Value, Fields!PersonID.Value, Fields!PhoneNumber.Value, "PhoneList"),",")  
    ```  
  
###  <a name="conversion-functions"></a><a name="ConversionFunctions"></a> Функции преобразования  
 Функции Visual Basic можно использовать для преобразования поля из одного типа данных в другой. Функции преобразования можно использовать, чтобы преобразовать тип данных по умолчанию для поля в тип данных, необходимый для вычислений или для объединения текста.  
  
-   Следующее выражение преобразует константу 500 в тип Decimal для сравнения с денежным типом данных Transact-SQL в поле Value для выражения фильтра.  
  
    ```  
    =CDec(500)  
    ```  
  
-   Следующее выражение отображает количество значений, выбранных для многозначного параметра *MySelection*.  
  
    ```  
    =CStr(Parameters!MySelection.Count)  
    ```  
  
###  <a name="decision-functions"></a><a name="DecisionFunctions"></a> Функции выбора  
  
-   Функция **Iif** возвращает одно из двух значений в зависимости от того, истинно ли указанное выражение. В следующем выражении используется функция **Iif**, которая возвращает логическое значение **True**, если значение `LineTotal` больше 100. В противном случае возвращается значение **False**:  
  
    ```  
    =IIF(Fields!LineTotal.Value > 100, True, False)  
    ```  
  
-   Следующее выражение использует несколько функций **IIF** (так называемые вложенные IIF), возвращая одно из трех значений в зависимости от значения поля `PctComplete`. Следующее выражение может быть помещено в свойство цвета заливки текстового поля, чтобы изменять цвета фона в зависимости от значения текстового поля.  
  
    ```  
    =IIF(Fields!PctComplete.Value >= 10, "Green", IIF(Fields!PctComplete.Value >= 1, "Blue", "Red"))  
    ```  
  
     Значения, которые больше или равны 10, отображаются с зеленым фоном, от 1 до 9 — с синим фоном и меньше 1 — с красным фоном.  
  
-   Такого же эффекта можно добиться с помощью функции **Switch**. Функция **Switch** полезна при наличии трех и более проверяемых условий. Функция **Switch** возвращает значение, связанное с первым выражением ряда, которое оценивается как true:  
  
    ```  
    =Switch(Fields!PctComplete.Value >= 10, "Green", Fields!PctComplete.Value >= 1, "Blue", Fields!PctComplete.Value = 1, "Yellow", Fields!PctComplete.Value <= 0, "Red")  
    ```  
  
     Значения, больше или равные 10, отображаются с зеленым фоном, от 1 до 9 — с синим фоном, равные 1 — с желтым фоном и меньшие или равные 0 — с красным фоном.  
  
-   Проверяет значение поля `ImportantDate` и возвращает строку "Red", если прошло больше недели, в ином случае — "Blue". Это выражение позволяет управлять свойством Color текстового поля в элементе отчета:  
  
    ```  
    =IIF(DateDiff("d",Fields!ImportantDate.Value, Now())>7,"Red","Blue")  
    ```  
  
-   Проверяет значение поля `PhoneNumber` и возвращает строку "No Value", если это значение **NULL** (**Nothing** в Visual Basic); в противном случае возвращает значение телефонного номера. Это выражение позволяет управлять содержимым текстового поля в элементе отчета.  
  
    ```  
    =IIF(Fields!PhoneNumber.Value Is Nothing,"No Value",Fields!PhoneNumber.Value)  
    ```  
  
-   Проверяет значение поля `Department` и возвращает либо имя вложенного отчета, либо значение **NULL** (**Nothing** в Visual Basic). Это выражение может использоваться для условной детализации вложенных отчетов.  
  
    ```  
    =IIF(Fields!Department.Value = "Development", "EmployeeReport", Nothing)  
    ```  
  
-   Проверяет, не является ли значением поля NULL. Это выражение можно использовать для управления свойством **Hidden** элемента-изображения отчета. В следующем примере изображение, задаваемое полем [LargePhoto], отображается, только если значение поля не равно NULL.  
  
    ```  
    =IIF(IsNothing(Fields!LargePhoto.Value),True,False)  
    ```  
  
-   Функция **MonthName** возвращает строковое значение, содержащее название указанного месяца. В следующем примере в поле "Month" (Месяц) указано "NA" (Н/Д), если поле содержит значение 0.  
  
    ```  
    IIF(Fields!Month.Value=0,"NA",MonthName(IIF(Fields!Month.Value=0,1,Fields!Month.Value)))  
  
    ```  
  
##  <a name="report-functions"></a><a name="ReportFunctions"></a> Функции отчета  
 В выражение можно добавить ссылку на дополнительные функции, которые позволяют управлять данными в отчете. В этом разделе приведены примеры использования двух из этих функций. 
  
###  <a name="sum"></a><a name="Sum"></a> Sum  
  
-   Функция **Sum** суммирует значения в группе или области данных. Она может быть полезна в колонтитулах группы. Следующее выражение отображает сумму данных в группе или области данных Order:  
  
    ```  
    =Sum(Fields!LineTotal.Value, "Order")  
    ```  
  
-   Функцию **Sum** можно также использовать для вычислений условных агрегатных функций. Например, если набор данных содержит поле State с возможными значениями «Not Started», «Started», «Finished», следующее значение, помещенное в верхний колонтитул группы, вычисляет статистическую сумму только для значения «Finished».  
  
    ```  
    =Sum(IIF(Fields!State.Value = "Finished", 1, 0))  
    ```  
  
###  <a name="rownumber"></a><a name="RowNumber"></a> RowNumber  
  
-   Если функция **RowNumber** используется в текстовом поле в области данных, то она отображает номер строки для каждого экземпляра текстового поля, в котором содержится это выражение. Эта функция может оказаться полезной для нумерации строк в таблице. Также она может быть полезна для более сложных задач, например для разбивки на страницы по определенному числу строк. Дополнительные сведения см. в подразделе [Разрывы страниц](#PageBreaks) далее в этом разделе.  
  
     Область, указанная для элементов управления **RowNumber** , когда начинается перенумерация. Ключевое слово **Nothing** указывает, что функция начнет нумерацию строк с первой строки самой внешней области данных. Чтобы начать подсчет внутри вложенных областей данных, используйте имя соответствующей области данных. Чтобы начать подсчет внутри группы, используйте ее имя.  
  
    ```  
    =RowNumber(Nothing)  
    ```  
  
##  <a name="appearance-of-report-data"></a><a name="AppearanceofReportData"></a> Внешний вид данных отчета  
 Выражения позволяют изменять внешний вид данных в отчете. Например, можно отобразить значения двух полей в одном текстовом поле, вывести сведения об отчете или изменить порядок разбиения на страницы.  
  
###  <a name="page-headers-and-footers"></a><a name="PageHeadersandFooters"></a> Верхние и нижние колонтитулы страницы  
 При проектировании отчета может понадобиться вывести в нижнем колонтитуле имя отчета и номер страницы. Для этого можно воспользоваться указанными ниже выражениями.  
  
-   Следующее выражение выдает имя отчета и время его запуска. Его можно указать в текстовом поле в нижнем колонтитуле или в теле отчета. Время форматируется с помощью строки форматирования .NET Framework для краткой даты:  
  
    ```  
    =Globals.ReportName & ", dated " & Format(Globals.ExecutionTime, "d")  
    ```  
  
-   Следующее выражение, если его поместить в текстовое поле в нижнем колонтитуле отчета, выводит номер страницы и общее число страниц, содержащихся в отчете:  
  
    ```  
    =Globals.PageNumber & " of " & Globals.TotalPages  
    ```  
  
 В следующих примерах показано, как вывести в верхнем колонтитуле страницы первое и последнее значение на странице, получив результат, похожий на список каталогов. Подразумевается, что в области данных существует текстовое поле `LastName`.  
  
-   Следующее выражение, помещенное в текстовое поле в левой части верхнего колонтитула, выводит первое значение текстового поля `LastName` на этой странице:  
  
    ```  
    =First(ReportItems("LastName").Value)  
    ```  
  
-   Следующее выражение, помещенное в текстовое поле в правой части верхнего колонтитула, выводит последнее значение текстового поля `LastName` на этой странице:  
  
    ```  
    =Last(ReportItems("LastName").Value)  
    ```  
  
 В следующем примере показано, как отобразить общее количество страниц. Подразумевается, что в области данных существует текстовое поле `Cost`.  
  
-   Следующее выражение, помещенное в верхний или нижний колонтитул, выводит сумму значений в текстовом поле `Cost` для этой страницы:  
  
    ```  
    =Sum(ReportItems("Cost").Value)  
    ```  
  
> [!NOTE]  
>  В колонтитуле для каждого выражения можно ссылаться только на один элемент отчета. Кроме того, в выражениях верхнего и нижнего колонтитулов можно ссылаться на имя текстового поля, но не на фактическое выражение данных в текстовом поле.  
  
###  <a name="page-breaks"></a><a name="PageBreaks"></a> Разрывы страниц  
 В некоторых отчетах может понадобиться вставить разрыв страницы после указанного числа строк вместо разрывов, вставляемых по группам или элементам отчета, или в дополнение к ним. Для этого создайте группу, содержащую необходимые группы или записи сведений, добавьте к группе разрыв страницы, а затем добавьте выражение группы для группирования по указанному числу строк.  
  
-   Следующее выражение, будучи указанным в качестве выражения группы, назначает номер каждому набору из 25 строк. Если для этой группы определен разрыв страницы, данное выражение будет вставлять его через каждые 25 строк.  
  
    ```  
    =Ceiling(RowNumber(Nothing)/25)  
    ```  
  
     Чтобы позволить пользователю устанавливать значение числа строк на странице, создайте параметр с именем `RowsPerPage` и используйте его в качестве основы для выражения группы, как показано в следующем выражении:  
  
    ```  
    =Ceiling(RowNumber(Nothing)/Parameters!RowsPerPage.Value)  
    ```  
  
##  <a name="properties"></a><a name="Properties"></a> Свойства  
 Выражения используются не только для отображения данных в текстовых полях. С их помощью можно также изменять применение свойств к элементам отчета. Вы можете изменить стиль данных или видимость для элемента отчета.  
  
###  <a name="formatting"></a><a name="Formatting"></a> Форматирование  
  
-   Следующее выражение при использовании в свойстве Color текстового поля изменяет цвет текста в зависимости от значения поля `Profit`:  
  
    ```  
    =Iif(Fields!Profit.Value < 0, "Red", "Black")  
    ```  
  
     Можно также использовать объектную переменную `Me` языка Visual Basic. Эта переменная предоставляет другой способ сослаться на значение текстового поля.  
  
     `=Iif(Me.Value < 0, "Red", "Black")`  
  
-   Если указать следующее выражение в свойстве BackgroundColor элемента отчета в области данных, цвет фона каждой строки переключается между бледно-зеленым и белым:  
  
    ```  
    =Iif(RowNumber(Nothing) Mod 2, "PaleGreen", "White")  
    ```  
  
     Возможно, что при использовании выражения для конкретной области понадобится указать набор данных для агрегатной функции:  
  
    ```  
    =Iif(RowNumber("Employees") Mod 2, "PaleGreen", "White")  
    ```  
  
> [!NOTE]  
>  Доступные цвета выбираются из перечисления KnownColor платформы .NET Framework.  
  
### <a name="chart-colors"></a>Цвета диаграммы  
 Чтобы задать цвета для фигурной диаграммы, нужно с помощью пользовательского кода изменить порядок сопоставления цветов со значениями точек данных. Это дает возможность использовать согласованные цвета в нескольких диаграммах, использующих одни и те же группы категорий. 
  
###  <a name="visibility"></a><a name="Visibility"></a> Видимость  
 Изменяя значения свойства видимости, можно скрывать и отображать элементы отчета. В области данных (например, в таблице) можно в зависимости от значения выражения изначально скрыть некоторые из строк подробностей.  
  
-   Если указать следующее выражение для определения начальной видимости строк сведений в группе, они отображаются только для продаж со значением более 90 % в поле `PctQuota`:  
  
    ```  
    =Iif(Fields!PctQuota.Value>.9, False, True)  
    ```  
  
-   Если указать следующее выражение для свойства Hidden таблицы, то таблица будет показана, только если в ней больше 12 строк.  
  
    ```  
    =IIF(CountRows()>12,false,true)  
    ```  
  
-   Когда для свойства **Hidden** столбца указано следующее выражение, столбец отображается только в том случае, если поле существует в наборе данных отчета после извлечения данных из источника данных:  
  
    ```  
    =IIF(Fields!Column_1.IsMissing, true, false)  
    ```  
  
###  <a name="urls"></a><a name="Hyperlinks"></a> URL-адреса  
 Можно настраивать URL-адреса с помощью данных отчета, а также с помощью условий управлять добавлением URL-адресов в качестве действия для текстового поля.  
  
-   Следующее выражение, используемое как действие в текстовом поле, формирует настраиваемый URL-адрес, указывающий поле набора данных `EmployeeID` в качестве параметра URL-адреса.  
  
    ```  
    ="https://adventure-works/MyInfo?ID=" & Fields!EmployeeID.Value  
    ```  
  
-   Следующее выражение в зависимости от определенных условий управляет добавлением URL-адреса в текстовое поле. Это выражение зависит от параметра `IncludeURLs`, который позволяет пользователю решать, включать ли в отчет активные URL-адреса. Это выражение установлено в качестве действия для текстового поля. Установив параметр в значение False и просматривая затем отчет, можно экспортировать отчет Microsoft Excel без гиперссылок.  
  
    ```  
    =IIF(Parameters!IncludeURLs.Value,"https://adventure-works.com/productcatalog",Nothing)  
    ```  
  
##  <a name="report-data"></a><a name="ReportData"></a> Данные отчета  
 С помощью выражений можно управлять данными в отчете, например ссылаться на параметры и другие данные отчета. Можно даже изменить запрос, используемый для получения данных при построении отчета.  
  
###  <a name="parameters"></a><a name="Parameters"></a> Параметры  
 В параметрах выражения используются для изменения их значения по умолчанию. Например, можно использовать параметр для фильтрации данных для конкретного пользователя на основе идентификатора пользователя, применяемого для запуска отчета.  
  
-   Следующее выражение, если его указать в качестве значения по умолчанию для параметра, получает идентификатор пользователя, запустившего этот отчет:  
  
    ```  
    =User!UserID  
    ```  
  
-   С помощью глобальной коллекции **Parameters** можно ссылаться на параметр в параметре запроса, выражении фильтра, текстовом поле или другой области отчета. В следующем примере подразумевается, что параметр имеет имя *Department*:  
  
    ```  
    =Parameters!Department.Value  
    ```  
  
-   Параметр может быть создан в отчете, но установлен как скрытый. При выполнении отчета на сервере отчетов такой параметр не отображается на панели инструментов, и читатель отчета не может изменить это значение по умолчанию. Скрытый параметр можно использовать для установки значения по умолчанию в качестве пользовательской константы. Это значение можно использовать в любом выражении, включая выражение поля. Следующее выражение идентифицирует поле, задаваемое значением параметра по умолчанию для параметра с именем *ParameterField*:  
  
    ```  
    =Fields(Parameters!ParameterField.Value).Value  
    ```  
  
##  <a name="custom-code"></a><a name="CustomCode"></a> Пользовательский код  
 В отчет можно внедрять пользовательский код. 
  
### <a name="using-group-variables-for-custom-aggregation"></a>Использование групповых переменных для нестандартного агрегата  
 Можно инициализировать значение групповой переменной, которая является локальной для определенной области группы, а затем включать в выражения ссылку на эту переменную. Одним из способов использования групповой переменной в пользовательском коде является реализация нестандартного агрегата. 
  
## <a name="suppressing-null-or-zero-values-at-run-time"></a>Подавление значения NULL или нулевых значений во время выполнения  
 Во время обработки отчета вычисление некоторых значений в выражении может давать NULL или неопределенный результат. Это может вызывать ошибки времени выполнения, которые приводят к отображению в текстовом поле значения **#Error** вместо вычисленного выражения. Функция **IIF** особенно чувствительна к такому поведению, так как, в отличие от инструкции If-Then-Else, каждая часть инструкции **IIF** оценивается (включая вызовы функций) перед передачей в подпрограмму, которая проверяет значения на равенство **true** или **false**. Инструкция `=IIF(Fields!Sales.Value is NOTHING, 0, Fields!Sales.Value)` формирует значение **#Error** в отчете, готовом для просмотра, если `Fields!Sales.Value` имеет значение NOTHING.  
  
 Чтобы избежать этого состояния, используйте одну из следующих стратегий.  
  
-   Установите числитель в 0, а знаменатель в 1, если значение поля B равно 0 или не определено; в противном случае установите в качестве числителя значение поля А, а в качестве знаменателя — значение поля B.  
  
    ```  
    =IIF(Field!B.Value=0, 0, Field!A.Value / IIF(Field!B.Value =0, 1, Field!B.Value))  
    ```  
  
-   Используйте функцию пользовательского кода, чтобы возвратить значение для выражения. Следующий пример возвращает процентную разницу между текущим и предыдущим значениями. Этот пример может использоваться для вычисления разницы между двумя последовательными значениями. В нем обрабатывается пограничный случай первого сравнения (когда нет предыдущего значения) и случаи, когда либо предыдущее значение, либо текущее значение равно **NULL** (**Nothing** в Visual Basic).  
  
    ```  
    Public Function GetDeltaPercentage(ByVal PreviousValue, ByVal CurrentValue) As Object  
        If IsNothing(PreviousValue) OR IsNothing(CurrentValue) Then  
            Return Nothing  
        Else if PreviousValue = 0 OR CurrentValue = 0 Then  
            Return Nothing  
        Else   
            Return (CurrentValue - PreviousValue) / CurrentValue  
        End If  
    End Function  
    ```  
  
     Следующее выражение показывает, как вызвать этот пользовательский код из текстового поля для контейнера ColumnGroupByYear (области данных или группы).  
  
    ```  
    =Code.GetDeltaPercentage(Previous(Sum(Fields!Sales.Value),"ColumnGroupByYear"), Sum(Fields!Sales.Value))  
    ```  
  
     Это помогает избежать исключений во время выполнения. Чтобы отобразить текст по условию того, являются ли значения меньше или больше 0, можно использовать выражение, подобное `=IIF(Me.Value < 0, "red", "black")`, в свойстве **Color** текстового поля.  
  
## <a name="next-steps"></a>Дальнейшие действия

- [Сведения об отчетах с разбивкой на страницы в Power BI Premium](paginated-reports-report-builder-power-bi.md)
  
